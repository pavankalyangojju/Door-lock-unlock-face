# --- IMPORTS ---
import cv2
import pickle
import numpy as np
import time
import pyttsx3
import RPi.GPIO as GPIO
import smbus2
import threading
from mfrc522 import SimpleMFRC522
from sklearn.neighbors import KNeighborsClassifier
from telegram.ext import Updater, CommandHandler

# --- GPIO SETUP ---
GPIO.setmode(GPIO.BCM)
BUZZER_PIN = 17
SERVO_PIN = 26
LED_PIN = 19
FAN_PIN = 13

GPIO.setup(BUZZER_PIN, GPIO.OUT)
GPIO.setup(SERVO_PIN, GPIO.OUT)
GPIO.setup(LED_PIN, GPIO.OUT)
GPIO.setup(FAN_PIN, GPIO.OUT)

GPIO.output(BUZZER_PIN, GPIO.LOW)
GPIO.output(LED_PIN, GPIO.LOW)
GPIO.output(FAN_PIN, GPIO.LOW)

servo = GPIO.PWM(SERVO_PIN, 50)
servo.start(0)

# --- LCD SETUP ---
LCD_ADDRESS = 0x27
LCD_WIDTH = 16
LCD_CHR = 1
LCD_CMD = 0
LINE_1 = 0x80
LINE_2 = 0xC0
LCD_BACKLIGHT = 0x08
ENABLE = 0b00000100
bus = smbus2.SMBus(1)

def lcd_byte(bits, mode):
    high_bits = mode | (bits & 0xF0) | LCD_BACKLIGHT
    low_bits = mode | ((bits << 4) & 0xF0) | LCD_BACKLIGHT
    bus.write_byte(LCD_ADDRESS, high_bits)
    lcd_toggle_enable(high_bits)
    bus.write_byte(LCD_ADDRESS, low_bits)
    lcd_toggle_enable(low_bits)

def lcd_toggle_enable(bits):
    time.sleep(0.0005)
    bus.write_byte(LCD_ADDRESS, bits | ENABLE)
    time.sleep(0.0005)
    bus.write_byte(LCD_ADDRESS, bits & ~ENABLE)
    time.sleep(0.0005)

def lcd_init():
    lcd_byte(0x33, LCD_CMD)
    lcd_byte(0x32, LCD_CMD)
    lcd_byte(0x06, LCD_CMD)
    lcd_byte(0x0C, LCD_CMD)
    lcd_byte(0x28, LCD_CMD)
    lcd_byte(0x01, LCD_CMD)
    time.sleep(0.005)

def lcd_display(message, line):
    lcd_byte(line, LCD_CMD)
    message = message.ljust(LCD_WIDTH, " ")
    for char in message:
        lcd_byte(ord(char), LCD_CHR)

def lcd_clear():
    lcd_display("", LINE_1)
    lcd_display("", LINE_2)

# --- LCD STARTUP ---
lcd_init()
lcd_display("Hi, welcome", LINE_1)
lcd_display("Door Access Sys", LINE_2)
time.sleep(3)
lcd_clear()

# --- Other Modules ---
engine = pyttsx3.init()
reader = SimpleMFRC522()

def speak(text):
    engine.say(text)
    engine.runAndWait()

# --- Servo Control ---
def unlock_door():
    print("Servo: Unlocking (180°)")
    servo.ChangeDutyCycle(12.0)
    time.sleep(1)
    servo.ChangeDutyCycle(0)

def lock_door():
    print("Servo: Locking (0°)")
    servo.ChangeDutyCycle(2.5)
    time.sleep(1)
    servo.ChangeDutyCycle(0)

# --- Telegram Bot ---
TELEGRAM_TOKEN = '7038070025:AAHOoUWmqVPvFmmITJKpbWVGcdwzLDmcVJI'

def led_on(update, context):
    GPIO.output(LED_PIN, GPIO.HIGH)
    update.message.reply_text("LED ON")

def led_off(update, context):
    GPIO.output(LED_PIN, GPIO.LOW)
    update.message.reply_text("LED OFF")

def fan_on(update, context):
    GPIO.output(FAN_PIN, GPIO.HIGH)
    update.message.reply_text("Fan ON")

def fan_off(update, context):
    GPIO.output(FAN_PIN, GPIO.LOW)
    update.message.reply_text("Fan OFF")

def start_bot():
    updater = Updater(TELEGRAM_TOKEN, use_context=True)
    dp = updater.dispatcher
    dp.add_handler(CommandHandler("led_on", led_on))
    dp.add_handler(CommandHandler("led_off", led_off))
    dp.add_handler(CommandHandler("fan_on", fan_on))
    dp.add_handler(CommandHandler("fan_off", fan_off))
    updater.start_polling()

bot_thread = threading.Thread(target=start_bot)
bot_thread.daemon = True
bot_thread.start()

# --- RFID EXIT MODE ---
def rfid_exit_mode():
    while True:
        try:
            card_id, card_text = reader.read()
            if card_id in RFID_LIST:
                user_index = RFID_LIST.index(card_id)
                name = LABELS[user_index]

                lcd_clear()
                lcd_display("Exit Granted", LINE_1)
                lcd_display(f"Bye {name}", LINE_2)
                speak(f"Goodbye {name}")
                GPIO.output(LED_PIN, GPIO.HIGH)
                GPIO.output(FAN_PIN, GPIO.HIGH)
                unlock_door()
                time.sleep(5)
                lock_door()
                lcd_clear()
                lcd_display("Door Closed", LINE_1)
                time.sleep(2)
        except Exception as e:
            print("RFID Exit Error:", e)

# --- Start RFID Exit Thread ---
exit_thread = threading.Thread(target=rfid_exit_mode)
exit_thread.daemon = True
exit_thread.start()

# --- Load Face Data ---
video = cv2.VideoCapture(0)
facedetect = cv2.CascadeClassifier(cv2.data.haarcascades + 'haarcascade_frontalface_default.xml')

try:
    with open('data/names.pkl', ' 'rb') as w:
        LABELS = pickle.load(w)
    with open('data/faces_data.pkl', 'rb') as f:
        FACES = pickle.load(f)
    with open('data/rfid_data.pkl', 'rb') as r:
        RFID_LIST = pickle.load(r)
except Exception as e:
    print("Error loading data:", e)
    exit()

FACES = np.array(FACES).reshape(FACES.shape[0], -1)
knn = KNeighborsClassifier(n_neighbors=5)
knn.fit(FACES, LABELS)

# --- FACE ENTRY LOOP ---
RECOGNITION_THRESHOLD = 5000  # Adjust for accuracy

while True:
    lcd_clear()
    lcd_display("Show Your Face", LINE_1)
    lcd_display("To the Camera", LINE_2)

    ret, frame = video.read()
    if not ret:
        print("Camera error")
        break

    gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
    faces = facedetect.detectMultiScale(gray, 1.3, 5)

    for (x, y, w, h) in faces:
        crop_img = frame[y:y+h, x:x+w]
        resized_img = cv2.resize(crop_img, (50, 50)).flatten().reshape(1, -1)

        try:
            distances, indices = knn.kneighbors(resized_img, n_neighbors=1)
            if distances[0][0] < RECOGNITION_THRESHOLD:
                recognized_name = knn.predict(resized_img)[0]
                print("Face Recognized:", recognized_name)

                lcd_clear()
                lcd_display(f"Hi {recognized_name}", LINE_1)
                lcd_display("Door is Open", LINE_2)
                speak(f"Welcome {recognized_name}, door is open")
                GPIO.output(LED_PIN, GPIO.HIGH)
                GPIO.output(FAN_PIN, GPIO.HIGH)

                unlock_door()
                time.sleep(5)
                lock_door()

                lcd_clear()
                lcd_display("Door is Closed", LINE_1)
                speak("Door is closed")
                time.sleep(2)

                video.release()
                lcd_clear()
                lcd_display("You want to go out", LINE_1)
                lcd_display("Put card", LINE_2)
                speak("If you want to go out, please tap your card")
                time.sleep(5)

                video = cv2.VideoCapture(0)
                break
            else:
                print("Unrecognized face. Distance:", distances[0][0])
                lcd_clear()
                lcd_display("Access Denied", LINE_1)
                lcd_display("No access for you", LINE_2)
                speak("Access denied. No access for you")
                GPIO.output(BUZZER_PIN, GPIO.HIGH)
                time.sleep(1)
                GPIO.output(BUZZER_PIN, GPIO.LOW)
                time.sleep(2)

        except Exception as e:
            print("Face Prediction Error:", e)
            continue

    cv2.imshow("Camera", frame)
    if cv2.waitKey(1) & 0xFF == ord('q'):
        lcd_clear()
        break

# --- Cleanup ---
video.release()
cv2.destroyAllWindows()
servo.stop()
GPIO.cleanup()
