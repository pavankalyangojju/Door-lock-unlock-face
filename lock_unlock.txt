# --- IMPORTS ---
import cv2
import pickle
import numpy as np
import time
import pyttsx3
import RPi.GPIO as GPIO
import threading
from mfrc522 import SimpleMFRC522
from RPLCD.i2c import CharLCD
from sklearn.neighbors import KNeighborsClassifier
from telegram.ext import Updater, CommandHandler

# --- LCD SETUP ---
lcd = CharLCD(i2c_expander='PCF8574', address=0x27, port=1, cols=16, rows=2, dotsize=8)
lcd.clear()
lcd.write_string("Hi, welcome")
lcd.crlf()
lcd.write_string("Door Access Sys")
time.sleep(3)
lcd.clear()

# --- GPIO SETUP ---
GPIO.setwarnings(False)
GPIO.setmode(GPIO.BCM)
BUZZER_PIN = 17
SERVO_PIN = 26
LED_PIN = 19
FAN_PIN = 13

GPIO.setup(BUZZER_PIN, GPIO.OUT)
GPIO.setup(SERVO_PIN, GPIO.OUT)
GPIO.setup(LED_PIN, GPIO.OUT)
GPIO.setup(FAN_PIN, GPIO.OUT)

GPIO.output(BUZZER_PIN, GPIO.LOW)
GPIO.output(LED_PIN, GPIO.LOW)
GPIO.output(FAN_PIN, GPIO.LOW)

servo = GPIO.PWM(SERVO_PIN, 50)
servo.start(0)

# --- Voice Engine ---
engine = pyttsx3.init()
reader = SimpleMFRC522()

def speak(text):
    engine.say(text)
    engine.runAndWait()

# --- Servo Control ---
def unlock_door():
    print("Unlocking Door")
    servo.ChangeDutyCycle(12.0)
    time.sleep(1)
    servo.ChangeDutyCycle(0)

def lock_door():
    print("Locking Door")
    servo.ChangeDutyCycle(2.5)
    time.sleep(1)
    servo.ChangeDutyCycle(0)

# --- Telegram Bot (Optional Switch Control) ---
TELEGRAM_TOKEN = '7038070025:AAHOoUWmqVPvFmmITJKpbWVGcdwzLDmcVJI'

def led_on(update, context):
    GPIO.output(LED_PIN, GPIO.HIGH)
    update.message.reply_text("LED ON")

def led_off(update, context):
    GPIO.output(LED_PIN, GPIO.LOW)
    update.message.reply_text("LED OFF")

def fan_on(update, context):
    GPIO.output(FAN_PIN, GPIO.HIGH)
    update.message.reply_text("Fan ON")

def fan_off(update, context):
    GPIO.output(FAN_PIN, GPIO.LOW)
    update.message.reply_text("Fan OFF")

def start_bot():
    updater = Updater(TELEGRAM_TOKEN, use_context=True)
    dp = updater.dispatcher
    dp.add_handler(CommandHandler("led_on", led_on))
    dp.add_handler(CommandHandler("led_off", led_off))
    dp.add_handler(CommandHandler("fan_on", fan_on))
    dp.add_handler(CommandHandler("fan_off", fan_off))
    updater.start_polling()

bot_thread = threading.Thread(target=start_bot)
bot_thread.daemon = True
bot_thread.start()

# --- RFID Exit Logic ---
def rfid_exit_mode():
    while True:
        try:
            card_id, card_text = reader.read()
            if card_id in RFID_LIST:
                user_index = RFID_LIST.index(card_id)
                name = LABELS[user_index]
                lcd.clear()
                lcd.write_string("Exit Granted")
                lcd.crlf()
                lcd.write_string(f"Bye {name}")
                speak(f"Goodbye {name}")
                GPIO.output(LED_PIN, GPIO.HIGH)
                GPIO.output(FAN_PIN, GPIO.HIGH)
                unlock_door()
                time.sleep(5)
                lock_door()
                lcd.clear()
                lcd.write_string("Door Closed")
                time.sleep(2)
        except Exception as e:
            print("RFID Exit Error:", e)

exit_thread = threading.Thread(target=rfid_exit_mode)
exit_thread.daemon = True
exit_thread.start()

# --- Load Face Data ---
facedetect = cv2.CascadeClassifier(cv2.data.haarcascades + 'haarcascade_frontalface_default.xml')
video = cv2.VideoCapture(0)

try:
    with open('data/names.pkl', 'rb') as f:
        LABELS = pickle.load(f)
    with open('data/faces_data.pkl', 'rb') as f:
        FACES = pickle.load(f)
    with open('data/rfid_data.pkl', 'rb') as f:
        RFID_LIST = pickle.load(f)
except Exception as e:
    print("Error loading face/RFID data:", e)
    exit()

FACES = np.array(FACES).reshape(len(FACES), -1)
knn = KNeighborsClassifier(n_neighbors=5)
knn.fit(FACES, LABELS)

# --- FACE ENTRY LOOP ---
while True:
    lcd.clear()
    lcd.write_string("Show Your Face")
    lcd.crlf()
    lcd.write_string("To the Camera")

    ret, frame = video.read()
    if not ret:
        print("Camera error")
        break

    gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
    faces = facedetect.detectMultiScale(gray, 1.3, 5)

    for (x, y, w, h) in faces:
        crop_img = frame[y:y+h, x:x+w]
        resized_img = cv2.resize(crop_img, (50, 50)).flatten().reshape(1, -1)

        try:
            predicted_name = knn.predict(resized_img)[0]
            if predicted_name in LABELS:
                lcd.clear()
                lcd.write_string(f"Hi {predicted_name}")
                lcd.crlf()
                lcd.write_string("Door is Open")
                speak(f"Welcome {predicted_name}, door is open")
                GPIO.output(LED_PIN, GPIO.HIGH)
                GPIO.output(FAN_PIN, GPIO.HIGH)
                unlock_door()
                time.sleep(5)
                lock_door()
                lcd.clear()
                lcd.write_string("Door Closed")
                speak("Door is closed")
                time.sleep(2)

                # Prompt for exit
                video.release()
                lcd.clear()
                lcd.write_string("Want to go out?")
                lcd.crlf()
                lcd.write_string("Tap your card")
                speak("If you want to go out, please tap your card")
                time.sleep(5)
                video = cv2.VideoCapture(0)
                break
            else:
                lcd.clear()
                lcd.write_string("Access Denied")
                lcd.crlf()
                lcd.write_string("You don't have")
                speak("You don't have access")
                GPIO.output(BUZZER_PIN, GPIO.HIGH)
                time.sleep(1)
                GPIO.output(BUZZER_PIN, GPIO.LOW)
                time.sleep(2)

        except Exception as e:
            print("Face Prediction Error:", e)
            continue

    cv2.imshow("Camera", frame)
    if cv2.waitKey(1) & 0xFF == ord('q'):
        lcd.clear()
        break

# --- Cleanup ---
video.release()
cv2.destroyAllWindows()
servo.stop()
GPIO.cleanup()
